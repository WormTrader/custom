package com.wormtrader.custom.worms;
/********************************************************************
* @(#)BWWiseMan1.java 1.00 20130417
* Copyright © 2013 by Richard T. Salamone, Jr. All rights reserved.
*
* BWWiseMan1: Implements the Bill Williams "First Wise Man" as
* described in Trading Chaos 2nd Edition Chapter 9.
*
* @author Rick Salamone
* @version 1.00
* 20130417 rts created
* 20130502 rts rewrite to use signals rather than explicit orders
*******************************************************/
import com.wormtrader.bars.Bar;
import com.wormtrader.history.Tape;
import com.wormtrader.history.indicators.Alligator;
import com.wormtrader.history.indicators.Fractals;
import com.wormtrader.positions.TapeWorm;
import com.wormtrader.positions.*;
import com.shanebow.util.SBFormat;
import com.wormtrader.positions.signals.TradeSignal;

public final class BWWiseMan1
	extends TapeWorm
	{
	private static final String BEAR_REV = "\u21E3RB";
	private static final String BULL_REV = "\u21E1RB";
	private static final String UP_FRACTAL_BO = "\u2227BO";
	private static final String DN_FRACTAL_BO = "\u2228BO";

	/**
	* Possible states of this Wise Man worm: Not to be confused
	* with the state of a signal generated by this worm.
	*/
	private static final int WMFLAT=0;
	private static final int WMLONG=1;
	private static final int WMSHORT=2;
	private static final int CANCELED=3; // can order pending

	// following states return true for orderPending()
	private static final int WMLONG_SIG=4;
	private static final int WMSHORT_SIG=5;
	private static final int WMREV_LONG_SIG=6;
	private static final int WMREV_SHORT_SIG=7;

	private int fWMState; // State of the wise man as opposed to the signal's state
	private TradeSignal fMostRecentSignal;
	private int fCancelPrice;
	private Alligator fGator;
	private Fractals fFractals;
	private PositionLeg fLeg;
	private int fRecentSignalIndex;

	private boolean orderPending() { return fWMState >= WMLONG_SIG; }

	public void initTape(Tape tape)
		{
		fLeg = getLeg();
		fGator = new Alligator(tape);
		fFractals = (Fractals)tape.addStudy(Fractals.STUDY_NAME, "");
		}

	public String getShortName() { return "Wise1"; }

	public String getMetrics ( int index, Bar bar )
		{
		return fGator.getToolTipText(index, bar);
		}

	boolean isBullDiSignal(byte diType, int x)
		{
		return diType == Alligator.DI_BULL
		    && fGator.angulation100(x) > 200;
		}

	boolean isBearDiSignal(byte diType, int x)
		{
		return diType == Alligator.DI_BEAR
		    && fGator.angulation100(x) > 200;
		}

	public void automata( int x, Bar bar )
		{
		if ( x < 8 || orderPending())
			return;

		byte diType = fGator.diType(x);
		if (diType == Alligator.DI_NONE)
			return;

		if (isBearDiSignal(diType, x))
			signal(new W1BearSignal(this, bar, BEAR_REV, WMSHORT_SIG));
		else if (isBullDiSignal(diType, x))
			signal(new W1BullSignal(this, bar, BULL_REV, WMLONG_SIG));
/****
		switch(fWMState)
			{
			case WMFLAT:if (isBearDiSignal(diType, x))
									signal(new W1BearSignal(this, bar, BEAR_REV, WMSHORT_SIG), false);
								else if (isBullDiSignal(diType, x))
									signal(new W1BullSignal(this, bar, BULL_REV, WMLONG_SIG), false);
								return;

			case WMLONG:if (isBearDiSignal(diType, x))
									signal(new W1BearSignal(this, bar, BEAR_REV, WMREV_SHORT_SIG), false);
								return;

			case WMSHORT:if (isBullDiSignal(diType, x))
									signal(new W1BullSignal(this, bar, BULL_REV, WMREV_LONG_SIG), false);
								return;
			}
****/
		}

	private final class W1BearSignal extends TradeSignal
		{
		byte fFillAct = ACT_BTC; // may change to Long if sig bar becomes fractal

		W1BearSignal(TapeWorm aWorm, Bar aBar, String why, int newWMState)
			{
			super(aWorm, ACT_SHORT, aBar.getLow()-1, aBar.getHigh()+1, why);
			setWMState(newWMState, 127);
			}

		@Override public void setState(byte aState)
			{
			switch (aState)
				{
				case FILLED:	// set a stop or reverse just at former canel price
					setWMState(WMSHORT, 143);
					signal(new TradeSignal(worm(), fFillAct, fCancel+1, 0, "Fail "+BEAR_REV));
					break;

				case CANCELED:
				case ERROR:
//try {
					int qty = fLeg.getQty();
//if (qty ==0) throw new IllegalArgumentException("New state " + STATE_DESC[aState]);
					setWMState((qty > 0)? WMLONG : (qty < 0)? WMSHORT : WMFLAT, 150);
//}catch(Exception e) { e.printStackTrace(); }
					break;
				}
			super.setState(aState);
			}
		}

	private final class W1BullSignal extends TradeSignal
		{
		byte fFillAct = ACT_STC; // ACT_SELL; // changes to short if sig bar becomes fractal

		W1BullSignal(TapeWorm aWorm, Bar aBar, String why, int newWMState)
			{
			super(aWorm, ACT_LONG, aBar.getHigh()+1, aBar.getLow()-1, why);
			setWMState(newWMState, 164);
			}

		@Override public void setState(byte aState)
			{
			switch (aState)
				{
				case FILLED:	// set a stop or reverse just at former canel price
					setWMState(WMLONG, 172);
					signal(new TradeSignal(worm(), fFillAct, fCancel-1, 0, "Fail "+BULL_REV));
					break;

				case CANCELED:
				case ERROR:
					int qty = fLeg.getQty();
					setWMState((qty > 0)? WMLONG : (qty < 0)? WMSHORT : WMFLAT, 179);
					break;
				}
			super.setState(aState);
			}
		}

	private static String[] STATES=
		{	"WMFLAT","WMLONG","WMSHORT","CANCELED",
			"WMLONG_SIG","WMSHORT_SIG","WMREV_LONG_SIG","WMREV_SHORT_SIG" };
	private void setWMState(int newState, int line)
		{
		log("" + line + ": " + STATES[fWMState] + " -> " + STATES[newState]);
		fWMState = newState;
		}
	}